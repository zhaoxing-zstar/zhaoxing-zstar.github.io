<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="Zstar,Share,Record,Document,Thoughts,Materials,Blog" />
       
      <meta name="description" content="Zstar Home Page" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>HFT_return |  Zstar Pages</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-HFT-return"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  HFT_return
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/03/HFT-return/" class="article-date">
  <time datetime="2023-07-02T16:38:57.000Z" itemprop="datePublished">2023-07-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Learn/">Learn</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">15 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="How-and-When-are-High-Frequency-Stock-Returns-Predictable"><a href="#How-and-When-are-High-Frequency-Stock-Returns-Predictable" class="headerlink" title="How and When are High-Frequency Stock Returns Predictable?"></a>How and When are High-Frequency Stock Returns Predictable?</h1><ul>
<li>NBER Working Paper.</li>
</ul>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>低频和long horizon的return的可预测性不高且变化无常，高频收益的可预测性更加可靠，系统且较为集中。根据从trades和quotes data中确定的相关的预测变量， 研究了什么决定了不同股票的自身特点和市场环境的可预测性的差异。并计算预测能力随着数据时效性提高而改善的程度。最后，通过模拟能够提前获知不完美的订单流来检验能否影响后续return和duration的预测性， 这是高频交易者常常能够得到的look ahead information。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>作者发现几乎所有的利息在所有股票和较短的时段内都能够很强并且一致的被预测， 包括，短期内价格变动，方向，大小和动量，以及连续到达的orders和transcations之间的间隔，都可以被预测。低频可预测性的问题对于金融市场的有效性以及资产配置策略具有重要的意义。另一方面，高频可预测性的问题对于金融市场的设计、运营和监管的理论含义以及交易和执行策略的实践具有重要的影响。</p>
<p>过去15年各种高频交易公司所取得的丰厚且连续的收益仿佛验证了高频收益的可预测性，但学界对这方面的研究不如低频深入。在本论文中，除过量化数据中存在的可预测性以及消散速度，也试图确定哪些预测变量对下一笔交易和间隔最有信息量。文章使用了trade和quotes data, 使用的机器学习方法有LASSO, RF, NN，并且不同的方法对最终结论影响较小，未使用probabilistic or statistical方法的原因是<strong>发现从LOB的state和evolution的得到的变量对收益的预测效果不如从transcation record中得到的变量</strong>, 下面作者阐述了一些贡献，总结：</p>
<p>a. 使用的数据是S&amp;P 100 index Jan 2019 - Dec 2020的101只股票的transcations和quote data. 所有股票的out of sample可预测性在不同时段都存在。5秒的收益样本外$R^2$为10.5%， 下一单的方向准确率为$64%$,预测下来10笔交易的间隔，样本外$R^2$为$9.8%$, 以上都为median。 return和方向的预测，重要的predictor有order book imbalance, recent transcation imbalance,以及 past trade returns, 但从最近的trade volume得到的统计量对duration的预测更有效。这里主要是作者有构建一些predictor，并观察feature importance得出的结论。</p>
<p>b. return和trade方向对名义股价较小，流动性较差，波动性较小，与总体市值相关性较小的股票更好预测</p>
<p>c. 收益的可预测性5min内就会刷见到0，大概是2000次交易或是2000手交易量</p>
<p>d. latency或是数据的delay会显著降低预测的准确性</p>
<p>e. “look ahead” at the incoming flow的能力，即使是一个不完美的方向预测，会将5min return预测的$R^2$从$14.0%$提升至$27.1%$, price方向的准确性也会从$68.3%$提升至$79.0%$</p>
<p>f. 另外的一些实验比较有:使用不同机器学习方法和调参算法的稳健性，predictability如何随time of the day变化，trades和quotes data的单独重要性，以及使用其它股票信息的用处。</p>
<h1 id="2-Response-and-Predictor-Variables"><a href="#2-Response-and-Predictor-Variables" class="headerlink" title="2. Response and Predictor Variables."></a>2. Response and Predictor Variables.</h1><h2 id="2-1-Transactions-and-Quotes-Data"><a href="#2-1-Transactions-and-Quotes-Data" class="headerlink" title="2.1 Transactions and Quotes Data"></a>2.1 Transactions and Quotes Data</h2><p>所使用的研究数据如下, trade data的order放下给是通过Lee and Ready(1991)的算法决定的，+1代表buy-initiated trade, -1代表sell-initiated trade. 然后trade data和quote data根据时间戳进行合并，并且只保留正常交易时段的数据.<br><img src="/images/hft_return/data.png" alt="data"><br>下表的上半部分代表了数据在daily level的统计值，下半部分代表了response variables的统计信息，同时，数据做了downsample来保证每天每只股票的数量大致相同。<br><img src="/images/hft_return/data_summary.png" alt="data summary"></p>
<h2 id="2-2-Response-Variables"><a href="#2-2-Response-Variables" class="headerlink" title="2.2 Response Variables."></a>2.2 Response Variables.</h2><p>作者首先定义了三种Clock，</p>
<ul>
<li>calendar clock: 就是原本时间戳</li>
<li>transcation clock: number of transcations have taken place.</li>
<li>volume clock: total volume transacted.<br> 看公式也比较好理解, Int代表Interval, 给定起始时间T，一个span $\Delta &gt; 0$,，和一个clock mode $M \in {calendar, transaction, volume}$, 其中span代表在各自clock mode下的衡量。<br><img src="/images/hft_return/clock.png" alt="clock"></li>
</ul>
<p>$\bm{D}^{txn}$表示所有对应trade data的时间戳，$\bm{D}^{qt}$为其quote上的对应部分，就是离第一个set中每个t最近的在quote data中的时间戳构成的集合。$\bm{D} &#x3D; \bm{D}^{txn} \cup \bm{D}^{qt}$， NBBO（National Best Bid and Offer prices）通过index $t \in \bm{D}$获取， best bid price: $P_t^b$, best ask price: $P_t^a$, mid price:$P_t &#x3D; \frac{P_t^a + P_t^b}{2}$, best bid size: $S_t^b$, best ask size: $S_t^a$, $P_t^{txn}$为transacted price如果$t\in \bm{D}^{txn}$.</p>
<h3 id="2-2-2-Transaction-return"><a href="#2-2-2-Transaction-return" class="headerlink" title="2.2.2 Transaction return"></a>2.2.2 Transaction return</h3><p>transaction return definition:<br><img src="/images/hft_return/transaction_return.png" alt="transaction return"><br>即为一个transaction span内的平均收益</p>
<h3 id="2-2-3-Price-direction"><a href="#2-2-3-Price-direction" class="headerlink" title="2.2.3 Price direction"></a>2.2.3 Price direction</h3><p><img src="/images/hft_return/direction.png" alt="direction"><br>其中$\bar{R}(\Delta, M)$代表过去transaction return的均值</p>
<h3 id="2-2-4-Transaction-duration"><a href="#2-2-4-Transaction-duration" class="headerlink" title="2.2.4 Transaction duration"></a>2.2.4 Transaction duration</h3><p><img src="/images/hft_return/duration.png" alt="duration"></p>
<p>这里定义的duration只有mode是transaction或是volume的时候才是有用的，预测duration对taker的execution schedule和maker撤单速度需求都有用</p>
<h2 id="2-3-Predictor-Variables"><a href="#2-3-Predictor-Variables" class="headerlink" title="2.3 Predictor Variables"></a>2.3 Predictor Variables</h2><p>这一节主要讲如何构建一些预测变量以及loock back window. 对前面提到的三种不同的mode, lookback interval分别可以定义为:<br><img src="/images/hft_return/lookback_int.png" alt="lookback_int"></p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>lookback spans$(\Delta_1, \Delta_2)$</th>
</tr>
</thead>
<tbody><tr>
<td>Calendar</td>
<td>{(0,0.1), (0.1,0.2), (0.2,0.4), …, (12.8, 25.6)}</td>
</tr>
<tr>
<td>Transaction</td>
<td>{(0,1), (1,2), (2,4), …,(128,256)}</td>
</tr>
<tr>
<td>Volume</td>
<td>{(0,100), (100,200),(200,400),…,(12800,25600)}</td>
</tr>
</tbody></table>
<p>文中主要考虑了13个预测变量，可以划分为三大类，每个都在3个mode的9个lookback span下进行了实现:</p>
<h4 id="Volume-and-duration"><a href="#Volume-and-duration" class="headerlink" title="Volume and duration"></a>Volume and duration</h4><p><img src="/images/hft_return/volume_and_duration.png" alt="volume_and_duration"></p>
<h4 id="Return-and-imbalance"><a href="#Return-and-imbalance" class="headerlink" title="Return and imbalance"></a>Return and imbalance</h4><p><img src="/images/hft_return/return_and_imb.jpg" alt="return_and_imb"></p>
<h4 id="Speed-and-cost"><a href="#Speed-and-cost" class="headerlink" title="Speed and cost"></a>Speed and cost</h4><p><img src="/images/hft_return/speed_and_cost.png" alt="speed_and_cost"></p>
<h1 id="3-Machine-Learning-Methods"><a href="#3-Machine-Learning-Methods" class="headerlink" title="3.Machine Learning Methods"></a>3.Machine Learning Methods</h1><p>这一章主要介绍了用到的机器学习方法，主要有LASSO, RF, GBDT等，以及调参和衡量结果的metric。比较重要的是tuning, training, testing划分的方式：<br><img src="/images/hft_return/rolling_window.png" alt="rolling window"><br>基本是rolling window training的方式，但有一些细节的改变。假设有一个长度为40日的窗口，文中做法是先一分为二，划分为tuning period 20天，testing period 20天, tuning period中使用5天train, 5天test，总共有3份这样的数据，再根据在test上15天表现最好的超参选为后续5天train, 1天test的参数（图中黑线以下的示例），这样总共就有20天test的结果。结束后再把大的40天窗口roll forward 20天。</p>
<h1 id="4-Predictability-Results-for-Individual-Stocks"><a href="#4-Predictability-Results-for-Individual-Stocks" class="headerlink" title="4. Predictability Results for Individual Stocks."></a>4. Predictability Results for Individual Stocks.</h1><p>这里给出了S&amp;P 100支股票在2019-2020 505个交易日，使用117个变量（13 * 9 lookback spans）的结果。</p>
<h2 id="4-1-Transaction-Return-Prediction"><a href="#4-1-Transaction-Return-Prediction" class="headerlink" title="4.1 Transaction Return Prediction"></a>4.1 Transaction Return Prediction</h2><p><img src="/images/hft_return/4_1_return.png" alt="4_1_return"></p>
<p>图里给出了不同的target horizon的预测结果，每个box plot代表的都是平均的样本外$R^2$, 可以看到horizon越长结果越差，并且RF会比LASSO稍好。接下来使用5s的return分析比较重要的feature有: TxnImbalance和 PastReturn， 两者都是从transaction中得到的，同时能观察到比较有用的预测变量都是使用最近的数据，即lookback span为$(\Delta_1, \Delta_2) &#x3D; (0.0,0.1)$。另外一个启示可能是有时候trade和volume clock的return预测会比time return容易。</p>
<p><img src="/images/hft_return/lasso_magnitude.png" alt="Lasso variable"></p>
<p><img src="/images/hft_return/frequency_variable_group.png" alt="variable group"></p>
<p>这里也给出了预测不同的target每组预测变量被选中的频率，可以看到x轴后面几个gruop的预测变量经常被使用，但与Volume相关的频次就比较低。</p>
<h2 id="4-2-Price-Direction-Prediction"><a href="#4-2-Price-Direction-Prediction" class="headerlink" title="4.2 Price Direction Prediction"></a>4.2 Price Direction Prediction</h2><p><img src="/images/hft_return/direction_result.png" alt="direction prediction"><br>方向预测对较短的horizon，如5 seconds, 10 trade, 1000 shares，准确率是$64%$, 这里相比return预测有两点值得注意:LASSO和RF结果比骄接近、result更robust(更不分散)。</p>
<h2 id="4-3-Transaction-Duration-Prediction"><a href="#4-3-Transaction-Duration-Prediction" class="headerlink" title="4.3 Transaction Duration Prediction"></a>4.3 Transaction Duration Prediction</h2><p><img src="/images/hft_return/duration_result.png" alt="duration result"><br>这里做的是对成交数或成交量到达已经阈值所需时间的预测，与之前不同，这里预测的结果会随duration拉长而更准确，但是对预测更重要的feature变为了与volume相关的group。同时，duration prediction会使用所有group的feature，不像return预测时有很强的偏向性。<br><img src="/images/hft_return/duration_result_importance.png" alt="duration result imoprtance"></p>
<h2 id="4-4-Prediction-Consistency-Over-Time"><a href="#4-4-Prediction-Consistency-Over-Time" class="headerlink" title="4.4 Prediction Consistency Over Time"></a>4.4 Prediction Consistency Over Time</h2><p><img src="/images/hft_return/consistency.png" alt="consistency"></p>
<p>这一节给出了预测结果在时序上的表现，可预测性在时序上比较稳定，并且在Covid-19期间volatility的上升带来了显著的预测能力的下降。下一章更详细的研究了影响可预测性在截面和时序上差异的因素。</p>
<h1 id="5-Cross-Sectional-and-Time-Series-Determinants-of-Predictability"><a href="#5-Cross-Sectional-and-Time-Series-Determinants-of-Predictability" class="headerlink" title="5. Cross-Sectional and Time-Series Determinants of Predictability"></a>5. Cross-Sectional and Time-Series Determinants of Predictability</h1><h2 id="5-1-Nominal-Share-Price-Level-and-Price-Discreteness"><a href="#5-1-Nominal-Share-Price-Level-and-Price-Discreteness" class="headerlink" title="5.1 Nominal Share Price Level and Price Discreteness"></a>5.1 Nominal Share Price Level and Price Discreteness</h2><p>首先价格离散性会影响收益可预测性，简单理解就是股价越低，虽然最小变动单位是0.01，但报价一般都以5bps或者10bbps跳变，这就导致bid-ask spread会更大，这样便于估计买卖压力并更好预测短期回报和交易方向。下面的scatter plot也能反映nominal price和收益&#x2F;交易方向可预测性的负相关关系。但是，我们可以看到duration是与nominal price正相关的，可能解释是更大nominal price的股票liquidity更高，使得duration更好预期。</p>
<p><img src="/images/hft_return/nominal_price.png" alt="nominal price"></p>
<h2 id="5-2-Stock-Trading-Liquidity"><a href="#5-2-Stock-Trading-Liquidity" class="headerlink" title="5.2 Stock Trading Liquidity"></a>5.2 Stock Trading Liquidity</h2><p>这一节主要研究liquidity对个股收益的影响，作者用total traded dollar volume和percentage spread来衡量，图里结果反映了更好的liquidity（更高的volume或是更低的spread，使得收益和交易方向预测更难，但是duration变的更加容易预测。</p>
<p><img src="/images/hft_return/liquidity_scatter.png" alt="liquidity"></p>
<h2 id="5-3-Stock-Level-Volatility-and-Jumps"><a href="#5-3-Stock-Level-Volatility-and-Jumps" class="headerlink" title="5.3 Stock-Level Volatility and Jumps"></a>5.3 Stock-Level Volatility and Jumps</h2><p>volatility定义为一天内non-overlap的15s mid price return的std，jumps是一个binary dummies， 代表每天close-to-close的return是否在$3%-4%$, $4%-5%$以及大于$5%$的范围内，这里有panel regression的结果，结论是volatility对收益的可预测性有负向的影响，但是对duration的预测有帮助，jump同样是不利于收益预测，但有助于duration预测</p>
<h2 id="5-4-Asset-Pricing-Characteristics"><a href="#5-4-Asset-Pricing-Characteristics" class="headerlink" title="5.4 Asset Pricing Characteristics"></a>5.4 Asset Pricing Characteristics</h2><p>这一节检验了与index的beta，$R^2$，以及idiosyncratic volatilities对预测性的影响，idiosyncratic volatility定义为：</p>
<p>$$<br>Idiosyncratic\ Volatility &#x3D; \sqrt{1-Corr^2(\bm{R_x}, \bm{R_{SPY}})}SD(\bm{R_x})<br>$$</p>
<p>Panel regression结果显示beta和$R^2$与收益和方向的预测负相关，而idiosyncratic volatility和上一节中的结论基本一致。</p>
<h2 id="5-5-Market-Wide-Environment"><a href="#5-5-Market-Wide-Environment" class="headerlink" title="5.5 Market-Wide Environment"></a>5.5 Market-Wide Environment</h2><p>这一届检验市场情况和预测性的关系，market return用S&amp;P 500 close to close return表示，CBOE VIX用来表示market volatility，同样regression的结果显示市场volatility对收益和方向预测有反向效应，更大的市场波动使得一切更难预测。另外，当market return为正的时候相比大盘跌这些值更好预测，这个发现也与”leverage effect”相符。</p>
<h2 id="5-6-Multivariate-Stock-Level-Predictability"><a href="#5-6-Multivariate-Stock-Level-Predictability" class="headerlink" title="5.6 Multivariate Stock-Level Predictability"></a>5.6 Multivariate Stock-Level Predictability</h2><p>这里考虑以上提到的所有因素进行一个全面的多元panel regression分析，大多数解释变量的影响与之前的分析一致。总结：<strong>returns和trade direction对liquidity更小，less volatile，并且名义价更小，和市场相关性更低的股票是更好预测的</strong></p>
<p><img src="/images/hft_return/total_panel.png" alt="total panel"></p>
<h1 id="6-The-Value-of-a-Millisecond"><a href="#6-The-Value-of-a-Millisecond" class="headerlink" title="6. The Value of a Millisecond"></a>6. The Value of a Millisecond</h1><p>第6章回答了以下问题: 1. 过多久预测性会消失？ 2. 数据获取delay对预测性的影响？ 3. 如果能够进行非常简单的look ahead，可预测性是否会增加？</p>
<h2 id="6-1-The-Predictability-Lifespan"><a href="#6-1-The-Predictability-Lifespan" class="headerlink" title="6.1 The Predictability Lifespan"></a>6.1 The Predictability Lifespan</h2><p><strong>The predictability is very short lived.</strong> 对之前定义的三中clock，作者分别使用了Intel股票对应的horizons来检验第一个问题。下图中x代表不同的horizons，shaded area代表$95%$的置信区间。几乎所有的预测能力都会随着horizon拉长降低，returns只有在接下来3min，2000笔交易，500K volume之前是可以预测的。图中的plateau可能只是因为bias-variance trade off带来的，因为transaction更多的时候对平均收益的估计会更准确。</p>
<p><img src="/images/hft_return/horizon_disappear.png" alt="horizon disappear"></p>
<p>但对duration的在transaction clock下的预测来讲，在更长的horizon更容易预测因为horizon变长的时候transaction的数量会分布更均匀。在volume clock下更稳定并且逐渐降低。</p>
<p><img src="/images/hft_return/duration_horizon.png" alt="duration diminish"></p>
<h2 id="6-2-The-Impact-of-Delays-in-Acquiring-or-Processing-Data"><a href="#6-2-The-Impact-of-Delays-in-Acquiring-or-Processing-Data" class="headerlink" title="6.2 The Impact of Delays in Acquiring or Processing Data"></a>6.2 The Impact of Delays in Acquiring or Processing Data</h2><p><strong>Each millisecond is very valuable, or conversely every delay is costly.</strong> 这一节中引入一个delay $\delta$，来预测$R(T+\delta, \Delta, M)$，delay在不同的clock下有不同的含义，但是可预测性都会随着delay增加而显著降低。</p>
<p><img src="/images/hft_return/cost_delay.png" alt="cost delay"></p>
<h2 id="6-3-Peeking-into-the-Future"><a href="#6-3-Peeking-into-the-Future" class="headerlink" title="6.3 Peeking into the Future"></a>6.3 Peeking into the Future</h2><p>假设交易者能够提前获知一些order flow的信息，这种非完美的信息可能是因为有更深档的LOB数据，其他相关的securities或是futures的交易信息，或者是利用自己在其他交易所的quote反馈，与交易所更快的通讯等。</p>
<p><img src="/images/hft_return/bernoulli.png" alt="bernoulli"></p>
<p>通过引入这么一个包含未来信息，但是又受一个bernoulli分布影响的信息，p&#x3D;0.5时候完全代表一个noise。再将这个FlowDir与之前117个变量每一个交互将feature数量翻倍来进行预测。从结果来看，包含未来的transaction信息会将return的结果从14%提升到27%，ddirection的准确性从68%提升到79%，同时，随着信息减少(参数p增大)，效果也会衰减。<br><img src="/images/hft_return/peeking.png" alt="peeking"></p>
<h1 id="7-Robustness-Checks"><a href="#7-Robustness-Checks" class="headerlink" title="7. Robustness Checks"></a>7. Robustness Checks</h1><p>这一张主要是对整个流程和结果的robustness check。包括算法的选择，超参数的调节，单独使用transaction data或是quote data的影响，以及time of the day是否会造成可预测性的差异。</p>
<h2 id="7-1-Comparison-and-Consistency-of-Results-Across-Prediction-Methods"><a href="#7-1-Comparison-and-Consistency-of-Results-Across-Prediction-Methods" class="headerlink" title="7.1 Comparison and Consistency of Results Across Prediction Methods"></a>7.1 Comparison and Consistency of Results Across Prediction Methods</h2><p><img src="/images/hft_return/model_comparison.png" alt="model comparison"><br>从预测结果可以看到，所有的模型表现都比较接近，从LASSO到一些非线性模型的提升并不明显。OLS在一些test上表现不好可能是因为overfitting, 因为它的predictions很容易受noise影响，所以可能有几天产生了离ground truth很远的结果。</p>
<h2 id="7-2-Fine-tuning-the-Number-of-Trees-in-a-Random-Forest"><a href="#7-2-Fine-tuning-the-Number-of-Trees-in-a-Random-Forest" class="headerlink" title="7.2 Fine-tuning the Number of Trees in a Random Forest"></a>7.2 Fine-tuning the Number of Trees in a Random Forest</h2><p><img src="/images/hft_return/random_forest.png" alt="random forest"><br>random forests代表最基本的non-parametric method. 通过调节random forests中决策树的数量，可以看到对预测效果的提升是很小的。</p>
<h2 id="7-3-redictability-Using-Only-Subtypes-of-Data-Trades-vs-Quotes"><a href="#7-3-redictability-Using-Only-Subtypes-of-Data-Trades-vs-Quotes" class="headerlink" title="7.3 redictability Using Only Subtypes of Data: Trades vs. Quotes"></a>7.3 redictability Using Only Subtypes of Data: Trades vs. Quotes</h2><p>这一节通过只在每一个单独的data或者both的时间戳上计算出的预测变量来进行预测，结果表明在transaction-only的时间戳上得到的结果显著高于在quote-update only时间戳上的结果，这也与之前看到LASSO会给予从transaction得到特征更高权重的观察一致。这种现象的原因可能是由于两种数据时间戳时序分布的差异，也可能是transaction data噪音更少。<br><img src="/images/hft_return/different_data.png" alt="subtypes"></p>
<h2 id="7-4-Incremental-Predictability-Using-Additional-Data-From-Correlated-Stocks"><a href="#7-4-Incremental-Predictability-Using-Additional-Data-From-Correlated-Stocks" class="headerlink" title="7.4 Incremental Predictability Using Additional Data From Correlated Stocks"></a>7.4 Incremental Predictability Using Additional Data From Correlated Stocks</h2><p>相关股票的移动对预测要交易股票是有帮助的，这里选取了与Intel最相关的四只股票，来研究引入额外信息的影响。为了保持预测变量数量大体一致，这里每额外引入股票，都会降低lookback spans的数量。但是引入额外股票只带来了很小的提升，甚至30s return时还出现了$R^2$下降的情况。<br><img src="/images/hft_return/additional_stocks.png" alt="add stocks"></p>
<h2 id="7-5-Intraday-Seasonality-Predictability-Across-Different-Trading-Hours"><a href="#7-5-Intraday-Seasonality-Predictability-Across-Different-Trading-Hours" class="headerlink" title="7.5 Intraday Seasonality: Predictability Across Different Trading Hours"></a>7.5 Intraday Seasonality: Predictability Across Different Trading Hours</h2><p><img src="/images/hft_return/intraday.png" alt="imgs"><br>这里很有意思，研究了time of the day的影响。一般开闭盘的时候volatility会更高，中间会低一些，spreads一天内也会逐渐减小。文中先把一天化为9:30-10:00 opening session，10:00-15:30 midday session，15:30-16:00 closing session，再时序上只保留对应时段来做预测。结果显示<strong>return在一天之中相比开盘更好预测</strong>，<strong>可预测性在收盘之前最高</strong>，可能说明闭盘时候trading pattern更一致。</p>
<h1 id="8-Conclusion"><a href="#8-Conclusion" class="headerlink" title="8. Conclusion"></a>8. Conclusion</h1><ul>
<li>在ultra short频段上进行了三种预测，发现可预测性在股票中普遍存在。</li>
<li>liquid，volatility，nominal price，与市场相关性更小的securities更好预测，但更高的liquid和volatile会使得duration预测更容易。</li>
<li>可预测性消失很快，只集中在很短的窗口内，并且信息的delay或是ahead都会对预测结果有很大影响。</li>
<li>transaction data是最有价值的，调参和引入其他股票带来的结果提升不显著，intraday variability是值得被考虑的。</li>
</ul>
<p>Q：</p>
<ol>
<li>horizon should be matched with feature look back window</li>
<li>are different clocks can be combined with different sampling methods.</li>
<li>demean, de-market, use information from other stocks.</li>
<li>comparison of different models, the results?</li>
<li>stock demean?</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        Share
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/07/03/HFT-return/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/quantitative-finance/" rel="tag">quantitative finance</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2022/06/09/NLP-with-DL/" class="article-nav-link">
        <strong class="article-nav-caption">Next Post</strong>
        <div class="article-nav-title">CS224n: Natural Language Processing with Deep Learning</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> Zstar
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ZSTAR.svg" alt="Zstar Pages"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/Learn/">Resources</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>